// Generated by CoffeeScript 1.11.1
var Bill, Konnector, async, createKonnectors, fieldsToMigrate, fs, getKonnectorsToCreate, initializeKonnector, konnectorModules, konnectorResetValue, konnectorsToMigrate, log, migrateField, migrateFields, migrateKonnector, migrateKonnectors, migrations, patch060, patch381, patchOnlineNet, patches, path;

path = require('path');

fs = require('fs');

async = require('async');

log = require('printit')({
  prefix: 'init',
  date: true
});

Konnector = require('../models/konnector');

konnectorModules = require('../lib/konnector_hash');

Bill = require('../models/bill');

konnectorsToMigrate = [
  {
    oldSlug: 'captain_train',
    newSlug: 'trainline'
  }, {
    oldSlug: 'virginmobile',
    newSlug: 'virgin_mobile'
  }, {
    oldSlug: 'sncf',
    newSlug: 'voyages_sncf'
  }
];

fieldsToMigrate = [
  {
    model: Bill,
    vendor: 'SNCF',
    field: 'vendor',
    match: /^SNCF$/,
    replace: 'VOYAGES SNCF'
  }
];

patch060 = function(callback) {
  return Konnector.request('all', function(err, konnectors) {
    return async.eachSeries(konnectors, function(konnector, done) {
      var data, slug;
      if (konnector.fieldValues != null) {
        slug = konnector.slug;
        log.info("Cleaning fields for konnector " + slug + "...");
        konnector.cleanFieldValues();
        data = {
          fieldValues: konnector.fieldValues,
          accounts: konnector.accounts,
          password: konnector.password
        };
        return konnector.updateAttributes(data, function(err) {
          if (err) {
            log.info("An error occured cleaning konnector " + slug);
            log.error(err);
          } else {
            log.info("Fields for konnector " + slug + " are cleaned.");
          }
          return done();
        });
      } else {
        return done();
      }
    }, function(err) {
      return callback();
    });
  });
};

patch381 = function(callback) {
  return Konnector.request('all', function(err, konnectors) {
    return async.eachSeries(konnectors, function(konnector, done) {
      var data, slug;
      if (konnector.accounts.length === 0 && konnector.importErrorMessage) {
        data = {
          importErrorMessage: null
        };
        slug = konnector.slug;
        return konnector.updateAttributes(data, function(err) {
          if (err) {
            log.info("An error occured cleaning konnector " + slug);
            log.error(err);
          } else {
            log.info("Fields for konnector " + slug + " are cleaned.");
          }
          return done();
        });
      } else {
        return done();
      }
    }, function(err) {
      return callback();
    });
  });
};

patchOnlineNet = function(callback) {
  return Konnector.request('bySlug', {
    key: 'online_net'
  }, function(err, konnectors) {
    var account, accounts, i, konnector, len, newAccounts;
    if (err) {
      return callback(err);
    }
    if (!konnectors.length) {
      return callback();
    }
    konnector = konnectors[0];
    accounts = konnector.accounts;
    if ((accounts[0] != null) && accounts[0].username) {
      log.info("Starting migration for online.net konnector");
      newAccounts = [];
      for (i = 0, len = accounts.length; i < len; i++) {
        account = accounts[i];
        account.login = account.username;
        delete account.username;
        newAccounts.push(account);
      }
      return konnector.updateAttributes({
        accounts: newAccounts
      }, function(err) {
        if (err) {
          return callback(err);
        }
        log.info("Successfully updated online.net konnector");
        return callback();
      });
    } else {
      return callback();
    }
  });
};

patches = function(callback) {
  return patch060(function() {
    return patch381(function() {
      return patchOnlineNet(function() {
        return callback();
      });
    });
  });
};

migrations = function(callback) {
  return migrateKonnectors(function() {
    return migrateFields(function() {
      return callback();
    });
  });
};

module.exports = function(callback) {
  return patches(function() {
    return migrations(function() {
      return Konnector.all(function(err, konnectors) {
        var konnectorHash;
        if (err) {
          log.error(err);
          return callback(err);
        } else {
          konnectorHash = {};
          return async.eachSeries(konnectors, function(konnector, done) {
            konnectorHash[konnector.slug] = konnector;
            return konnectorResetValue(konnector, done);
          }, function(err) {
            var konnectorsToCreate;
            if (err) {
              log.error(err);
            }
            konnectorsToCreate = getKonnectorsToCreate(konnectorHash);
            if (konnectorsToCreate.length === 0) {
              return callback();
            } else {
              return createKonnectors(konnectorsToCreate, callback);
            }
          });
        }
      });
    });
  });
};

konnectorResetValue = function(konnector, callback) {
  var data;
  if (konnector.isImporting || konnector.fieldValues) {
    log.info("Reseting isImporting field for " + konnector.slug + "...");
    konnector.cleanFieldValues();
    data = {
      isImporting: false
    };
    return konnector.updateAttributes(data, function(err) {
      var slug;
      slug = konnector.slug;
      if (err) {
        log.info("An error occured reseting isImporting for " + slug);
        log.error(err);
      } else {
        log.info("IsImporting field for " + slug + " is reseted.");
        log.info(konnector.slug + " fields cleaned.");
      }
      return callback();
    });
  } else {
    return callback();
  }
};

getKonnectorsToCreate = function(konnectorHash) {
  var konnectorModule, konnectorsToCreate, name;
  konnectorsToCreate = [];
  for (name in konnectorModules) {
    konnectorModule = konnectorModules[name];
    if (konnectorHash[konnectorModule.slug] == null) {
      konnectorsToCreate.push(konnectorModule);
      log.info("New konnector to init: " + name);
    }
  }
  return konnectorsToCreate;
};

createKonnectors = function(konnectorsToCreate, callback) {
  return async.eachSeries(konnectorsToCreate, function(konnector, done) {
    return initializeKonnector(konnector, done);
  }, function(err) {
    if (err) {
      log.error(err);
      return callback(err);
    }
    log.info('All konnectors created');
    return callback();
  });
};

initializeKonnector = function(konnector, callback) {
  log.debug("creating " + konnector.slug);
  if (konnector.init != null) {
    return konnector.init(function(err) {
      if (err) {
        log.error(err);
        return callback(err);
      } else {
        return Konnector.create(konnector, function(err) {
          if (err) {
            log.error(err);
          }
          return callback(err);
        });
      }
    });
  } else {
    return Konnector.create(konnector, function(err) {
      if (err) {
        log.error(err);
      }
      return callback(err);
    });
  }
};

migrateKonnector = function(oldSlug, newSlug, callback) {
  return Konnector.request('bySlug', {
    key: oldSlug
  }, function(err, konnectors) {
    if (err) {
      return callback(err);
    }
    if (konnectors.length) {
      return konnectors[0].updateAttributes({
        slug: newSlug
      }, function(err) {
        if (err) {
          log.error(err);
          return callback(err);
        }
        log.info("Konnector with slug " + oldSlug + " successfully migrated to " + newSlug);
        return callback();
      });
    } else {
      return callback();
    }
  });
};

migrateKonnectors = function(callback) {
  return async.eachSeries(konnectorsToMigrate, function(slugs, done) {
    return migrateKonnector(slugs.oldSlug, slugs.newSlug, done);
  }, function(err) {
    if (err) {
      log.error(err);
      return callback(err);
    }
    log.info("All konnectors successfully migrated");
    return callback();
  });
};

migrateField = function(model, vendor, field, match, replace, callback) {
  return model.request('byVendor', {
    key: vendor
  }, function(err, entries) {
    var filteredEntries;
    if (err) {
      return callback(err);
    }
    filteredEntries = entries.filter(function(entry) {
      return entry[field].match(match).length;
    });
    if (filteredEntries.length) {
      return async.eachSeries(filteredEntries, function(entry, done) {
        var data, obj;
        data = (
          obj = {},
          obj["" + field] = entry[field].replace(match, replace),
          obj
        );
        return entry.updateAttributes(data, function(err) {
          if (err) {
            log.error(err);
            return done(err);
          }
          return done();
        });
      }, function(err) {
        if (err) {
          return callback(err);
        }
        log.info("Successfully migrated field " + field + " of " + model.displayName + " from " + match + " to " + replace);
        return callback();
      });
    } else {
      return callback();
    }
  });
};

migrateFields = function(callback) {
  return async.eachSeries(fieldsToMigrate, function(fieldToMigrate, done) {
    var field, match, model, replace, vendor;
    model = fieldToMigrate.model, vendor = fieldToMigrate.vendor, field = fieldToMigrate.field, match = fieldToMigrate.match, replace = fieldToMigrate.replace;
    return migrateField(model, vendor, field, match, replace, done);
  }, function(err) {
    if (err) {
      return callback(err);
    }
    log.info("Successfully migrated all fields");
    return callback();
  });
};
