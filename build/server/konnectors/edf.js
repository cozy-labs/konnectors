// Generated by CoffeeScript 1.11.1
var Bill, Client, ConsumptionStatement, Contract, File, Folder, Home, K, PaymentTerms, _edfRequestPost, _extend, async, buildNotifContent, builder, cozydb, createNewFile, displayData, edfRequestPost, fetchEdeliaData, fetchEdeliaElecIndexes, fetchEdeliaGasIndexes, fetchEdeliaMonthlyElecConsumptions, fetchEdeliaMonthlyGasConsumptions, fetchEdeliaProfile, fetchEdeliaSimilarHomeYearlyElecComparisions, fetchEdeliaSimilarHomeYearlyGasComparisions, fetchEdeliaToken, fetchListerContratClientParticulier, fetchPDF, fetchRecupereDocumentContractuelListx, fetchVisualiserAccordCommercial, fetchVisualiserCalendrierPaiement, fetchVisualiserHistoConso, fetchVisualiserPartenaire, fetcher, getEDFToken, getEdelia, getF, localization, logger, moment, parser, prepareEntries, request, saveMissingBills, translate, updateOrCreate, xml2js,
  slice = [].slice;

xml2js = require('xml2js');

request = require('request');

async = require('async');

moment = require('moment');

cozydb = require('cozydb');

localization = require('../lib/localization_manager');

fetcher = require('../lib/fetcher');

updateOrCreate = require('../lib/update_or_create');

File = require('../models/file');

Folder = require('../models/folder');

Client = require('../models/client');

Contract = require('../models/contract');

PaymentTerms = require('../models/paymentterms');

Home = require('../models/home');

ConsumptionStatement = require('../models/consumptionstatement');

Bill = require('../models/bill');

parser = new xml2js.Parser();

builder = new xml2js.Builder({
  headless: true
});

logger = require('printit')({
  prefix: 'EDF',
  date: true
});

getEDFToken = function(requiredFields, entries, data, callback) {
  var body, path;
  K.logger.info('getEDFToken');
  path = "/ws/authentifierUnClientParticulier_rest_V2-0/invoke";
  body = {
    "ns:msgRequete": {
      "$": {
        "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xsi:schemaLocation": "http://www.edf.fr/commerce/" + "passerelle/authentifierUnClientParticulier/service/v2/" + "message authentifierUnClientParticulier.xsd",
        "xmlns:ns": "http://www.edf.fr/commerce/passerelle/" + "authentifierUnClientParticulier/service/v2/message"
      },
      "ns:enteteEntree": [
        {
          "ns:idCanal": 5
        }
      ],
      "ns:corpsEntree": [
        {
          "ns:idAppelant": requiredFields.email,
          "ns:password": requiredFields.password
        }
      ]
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var errorCode, token;
    if (err) {
      return callback(err);
    }
    errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
    if (errorCode && errorCode !== '0000') {
      K.logger.error(getF(result, 'ns:enteteSortie', 'ent:libelleRetour '));
    }
    token = getF(result['ns:msgReponse'], 'ns:corpsSortie', 'ns:jeton');
    if (token != null) {
      K.logger.info("EDF token fetched");
      data.edfToken = token;
      return callback();
    } else {
      K.logger.error("Can't fetch EDF token");
      return callback('token not found');
    }
  });
};

fetchListerContratClientParticulier = function(reqFields, entries, data, callback) {
  var body, path;
  K.logger.info("fetch listerContratClientParticulier");
  path = '/ws/listerContratClientParticulier_rest_V4-0/invoke';
  body = {
    'msgRequete': {
      '$': {
        'xmlns': "http://www.edf.fr/commerce/passerelle/pas072/" + "listerContratClientParticulier/service/v3",
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
        'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "pas072/listerContratClientParticulier/service/" + "v3 listerContratClientParticulier.xsd"
      },
      'EnteteEntree': {
        'Jeton': data.edfToken
      }
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var addressObject, bpObject, civilite, client, coHolder, coTitulaireElem, codePostal, contracts, contratElems, e, errorCode, identiteObj, nom, nomRue, numRue, prenom, resBody, ville;
    if (err) {
      return callback(err);
    }
    try {
      errorCode = getF(result, 'tns:EnteteSortie', 'tns:CodeErreur');
      if (errorCode && errorCode !== 'PSC0000') {
        K.logger.error(getF(result, 'tns:EnteteSortie', 'tns:LibelleErreur'));
        return callback('request error');
      }
      client = {
        vendor: 'EDF',
        docTypeVersion: K.docTypeVersion
      };
      resBody = getF(result["tns:msgReponse"], "tns:CorpsSortie", 'tns:AccordCo');
      client.numeroAcc = getF(resBody, 'tns:Numero');
      bpObject = getF(resBody, 'tns:BP');
      client.clientId = getF(bpObject, 'tns:Numero');
      addressObject = getF(resBody, 'tns:Adresse');
      if (addressObject) {
        numRue = getF(addressObject, 'tns:NumRue') || "";
        nomRue = getF(addressObject, 'tns:NomRue') || "";
        codePostal = getF(addressObject, 'tns:CodePostal') || "";
        ville = getF(addressObject, 'tns:Ville') || "";
        client.address = {
          street: numRue + " " + nomRue,
          city: ville,
          postcode: codePostal,
          country: 'FRANCE',
          formated: numRue + " " + nomRue + "\n" + codePostal + " " + ville
        };
      }
      identiteObj = getF(bpObject, 'tns:Identite');
      civilite = getF(identiteObj, 'tns:Civilite') || '';
      nom = getF(identiteObj, 'tns:Nom') || '';
      prenom = getF(identiteObj, 'tns:Prenom') || '';
      client.name = {
        prefix: civilite,
        family: nom,
        given: prenom,
        formated: prenom + " " + nom
      };
      coTitulaireElem = getF(bpObject, 'tns:IdentitePart');
      if (coTitulaireElem) {
        coHolder = {
          family: getF(coTitulaireElem, 'tns:NomCoTitulaire'),
          given: getF(coTitulaireElem, 'tns:PrenomCoTitulaire')
        };
        coHolder.formated = coHolder.given + " " + coHolder.family;
        client.coHolder = coHolder;
      }
      client.email = getF(bpObject, 'tns:Coordonnees', 'tns:Email');
      client.cellPhone = getF(bpObject, 'tns:Coordonnees', 'tns:NumTelMobile');
      contratElems = resBody['tns:Contrat'];
      contracts = contratElems.map(function(contratElem) {
        var cadranElem, contract, counter, offreSouscriteObj, releveElem, services, statement, vieContratObj;
        contract = {
          vendor: 'EDF',
          clientId: client.clientId,
          docTypeVersion: K.docTypeVersion
        };
        contract.number = getF(contratElem, 'tns:Numero');
        contract.pdl = getF(contratElem, 'tns:NumeroPDL');
        vieContratObj = getF(contratElem, 'tns:VieDuContrat');
        contract.start = getF(vieContratObj, 'tns:DateDebut');
        contract.status = getF(vieContratObj, 'tns:Statut');
        contract.end = getF(vieContratObj, 'tns:DateFin');
        contract.terminationGrounds = getF(vieContratObj, 'tns:MotifResiliation');
        offreSouscriteObj = getF(contratElem, 'tns:OffreSouscrite');
        contract.energie = translate({
          ELECTRICITE: 'Électricité',
          GAZ: 'Gaz'
        }, getF(offreSouscriteObj, 'tns:Energie'));
        contract.name = translate({
          GN_2: 'Offre Gaz naturel',
          MCGN_2: 'Mon Contrat gaz naturel',
          MCGN_PRIX_FIXE_1: 'Mon Contrat Gaz Naturel a prix fixe',
          ELECTRICITE_PRO: 'Electricite Pro',
          ELEC_DEREGULE: 'Mon Contrat Electricite',
          ELEC_PRO_PX_FIXE_1: 'Electricite Pro a Prix Fixe',
          ESSENTIEL_PRO: 'Essentiel Pro',
          OFFRE_HC_SOUPLES: 'Heures Creuses Souples',
          PRESENCE_PRO: 'Presence Pro',
          SOUPLESSE_PRO: 'Souplesse Pro',
          TARIF_BLEU: 'Tarif Bleu',
          TARIF_BLEU_PART: 'Tarif Bleu',
          ESSENTIEL_GAZ: 'Essentiel Gaz',
          GAZ: 'Mon Contrat Gaz Naturel',
          GAZ_2: 'Mon Contrat Gaz Naturel',
          GAZ_NAT_PX_FIXE_1: 'Gaz Naturel a Prix Fixe',
          PRESENCE_GAZ: 'Presence Gaz',
          SOUPLESSE_GAZ: 'Souplesse Gaz',
          TARIF_BLEU_GAZ: 'Gaz Naturel',
          TARIF_EJP_PART: 'EJP',
          OFFRE_TPN: 'TPN'
        }, getF(offreSouscriteObj, 'tns:NomOffre'));
        contract.troubleshootingPhone = getF(offreSouscriteObj, 'tns:NumeroDepannageContrat');
        switch (contract.energie) {
          case 'Électricité':
            contract.power = translate({
              PUI00: '0 kVA',
              PUI03: '3 kVA',
              PUI06: '6 kVA',
              PUI09: '9 kVA',
              PUI12: '12 kVA',
              PUI15: '15 kVA',
              PUI18: '18 kVA',
              PUI24: '24 kVA',
              PUI30: '30 kVA',
              PUI36: '36 kVA'
            }, getF(offreSouscriteObj, 'tns:Puissance'));
            contract.contractSubcategory1 = getF(offreSouscriteObj, 'tns:StructureTarifaire');
            break;
          case 'Gaz':
            contract.contractSubcategory2 = getF(offreSouscriteObj, 'tns:OptionPrix');
        }
        cadranElem = getF(contratElem, 'tns:ListeCadran');
        if (cadranElem) {
          counter = {};
          counter.comptage = getF(cadranElem, 'tns:Type');
          counter.nombreRoues = getF(cadranElem, 'tns:NombreRoues');
          counter.dernierIndex = getF(cadranElem, 'tns:DernierIndex');
          counter.type = getF(contratElem, 'tns:DonneesTechniques', 'tns:TypeCompteur');
          contract.counter = counter;
          contract.annualConsumption = getF(cadranElem, 'tns:ConsommationAnnuelle');
        }
        contract.peakHours = getF(contratElem, 'tns:DonneesTechniques', 'tns:HorrairesHC');
        releveElem = getF(contratElem, 'tns:Releve');
        if (releveElem) {
          statement = {};
          statement.prochaineReleve = getF(releveElem, 'tns:ProchaineDateReleveReelle');
          statement.saisieReleveConfiance = getF(releveElem, 'tns:SaisieRC');
          statement.dateFermetureReleveConfiance = getF(releveElem, 'tns:DateFermetureRC');
          statement.prochaineDateOuvertureReleveConfiance = getF(releveElem, 'tns:ProchaineDateOuvertureRC');
          statement.prochaineDateFermetureReleveConfiance = getF(releveElem, 'tns:ProchaineDateFermetureRC');
          statement.prochaineDateFermetureReelle = getF(releveElem, 'tns:ProchaineDateFermetureReelle');
          statement.saisieSuiviConso = getF(releveElem, 'tns:SaisieSC');
          statement.prochaineDateOuvertureSaisieConso = getF(releveElem, 'tns:ProchaineDateOuvertureSC');
          contract.statement = statement;
        }
        contract.services = [];
        if (contratElem['tns:ServicesSouscrits']) {
          services = contratElem['tns:ServicesSouscrits'].map(function(serviceElem) {
            var service;
            service = {
              nom: getF(serviceElem, 'tns:NomService'),
              activ: getF(serviceElem, 'tns:Etat')
            };
            return service;
          });
          contract.services = contract.services.concat(services);
        }
        if (resBody['tns:ServicesSouscrits']) {
          services = resBody['tns:ServicesSouscrits'].map(function(serviceElem) {
            var service;
            service = {
              nom: getF(serviceElem, 'tns:nomService'),
              start: getF(serviceElem, 'tns:dateSouscription'),
              activ: getF(serviceElem, 'tns:statut')
            };
            return service;
          });
          contract.services = contract.services.concat(services);
        }
        return contract;
      });
      K.logger.info("Fetched listerContratClientParticulier");
      entries.clients.push(client);
      entries.contracts = contracts;
      return callback();
    } catch (error1) {
      e = error1;
      K.logger.error("While fetching listerContratClientParticulier", e);
      return callback(e);
    }
  });
};

fetchVisualiserPartenaire = function(requiredFields, entries, data, callback) {
  var body, path;
  K.logger.info("fetchVisualiserPartenaire");
  path = '/ws/visualiserPartenaire_rest_V2-0/invoke';
  body = {
    'msgRequete': {
      '$': {
        'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserPartenaire/service/v2 C:\\HMN\\EDFMoiV2\\WSDL" + "\\passerelle\\passerelle\\css\\visualiserPartenaire\\service" + "\\v2\\visualiserPartenaire.xsd",
        'xmlns': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserPartenaire/service/v2",
        'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete",
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
      },
      'enteteEntree': {
        'ent:jeton': data.edfToken
      },
      'corpsEntree': {
        'numeroBp': entries.clients[0].clientId
      }
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var address, addressElem, client, contact, contactElem, coordonneesElem, e, errorCode, partnerElem;
    if (err) {
      return callback(err);
    }
    try {
      errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
      if (errorCode && errorCode !== '0') {
        K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleRetour'));
        return callback();
      }
      partnerElem = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:partenaire");
      client = {};
      coordonneesElem = getF(partnerElem, 'ns:coordonnees');
      client.cellPhone = getF(coordonneesElem, 'ns:NumTelMobile');
      client.homePhone = getF(coordonneesElem, 'ns:NumTelFixe');
      client.email = getF(coordonneesElem, 'ns:Email');
      client.loginEmail = getF(coordonneesElem, 'ns:EmailAEL');
      contactElem = getF(partnerElem, 'ns:centreContact');
      contact = {};
      contact.title = getF(contactElem, 'ns:gsr');
      contact.phone = getF(contactElem, 'ns:telephone');
      addressElem = getF(contactElem, 'ns:adresse');
      if (addressElem) {
        address = {};
        address.street = getF(addressElem, 'ns:nomRue');
        address.postcode = getF(addressElem, 'ns:codePostal');
        address.city = getF(addressElem, 'ns:ville');
        address.formated = ("" + address.street) + ("\n" + address.postcode + " " + address.city);
        contact.address = address;
      }
      client.commercialContact = contact;
      entries.clients[0] = _extend(entries.clients[0], client);
      K.logger.info("Fetched visualiserPartenaire.");
      return callback();
    } catch (error1) {
      e = error1;
      K.logger.error("While fetching visualiserPartenaire.");
      K.logger.error(e);
      return callback(e);
    }
  });
};

fetchVisualiserAccordCommercial = function(requiredFields, entries, data, callback) {
  var body, path;
  K.logger.info("fetchVisualiserAccordCommercial");
  path = '/ws/visualiserAccordCommercial_rest_V2-0/invoke';
  body = {
    'msg:msgRequete': {
      '$': {
        'xmlns:dico': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/dico",
        'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/v2" + "/entete",
        'xmlns:msg': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserAccordCommercial/service/v2",
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
        'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserAccordCommercial/service/" + "v2 visualiserAccordCommercial.xsd"
      },
      'msg:enteteEntree': {
        'ent:jeton': data.edfToken
      },
      'msg:corpsEntree': {
        'msg:numeroBp': entries.clients[0].clientId,
        'msg:numeroAcc': entries.clients[0].numeroAcc
      }
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var acoElem, bankAddress, bankDetails, e, errorCode, paymentTerms, services, servicesElem;
    if (err) {
      return callback(err);
    }
    try {
      errorCode = getF(result, 'ns:enteteSortie', 'ent:codeErreur');
      if (errorCode && errorCode !== '0') {
        K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleErreur'));
        return callback();
      }
      acoElem = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:listeAccordCommerciaux", "ns:acordcommercial");
      paymentTerms = {
        vendor: 'EDF',
        clientId: entries.clients[0].clientId,
        docTypeVersion: K.docTypeVersion
      };
      bankDetails = {
        iban: getF(acoElem, 'ns:banque', 'ns:iban'),
        holder: getF(acoElem, 'ns:compte', 'ns:titulaire'),
        bank: getF(acoElem, "ns:banque", "ns:nom")
      };
      bankAddress = {
        street: getF(acoElem, 'ns:banque', 'ns:numNomRue'),
        city: getF(acoElem, 'ns:banque', 'ns:codePostalVille'),
        country: getF(acoElem, 'ns:banque', 'ns:pays')
      };
      bankAddress.formated = ("" + bankAddress.street) + ("\n" + bankAddress.city + " " + bankAddress.country);
      bankDetails.bankAddress = bankAddress;
      paymentTerms.encryptedBankDetails = JSON.stringify(bankDetails);
      paymentTerms.balance = getF(acoElem, 'ns:detail', 'ns:solde');
      paymentTerms.paymentMeans = getF(acoElem, 'ns:detail', 'ns:modeEncaissement');
      paymentTerms.modifBankDetailsAllowed = getF(acoElem, 'ns:detail', 'ns:modifIbanAutorisee');
      paymentTerms.dernierReglement = {
        date: getF(acoElem, 'ns:dernierReglement', 'ns:date'),
        amount: getF(acoElem, 'ns:dernierReglement', 'ns:montant'),
        type: getF(acoElem, 'ns:dernierReglement', 'ns:type')
      };
      paymentTerms.billFrequency = getF(acoElem, 'ns:facturation', 'ns:periodicite');
      paymentTerms.nextBillDate = getF(acoElem, 'ns:facturation', 'ns:dateProchaineFacture');
      paymentTerms.idPayer = getF(acoElem, 'ns:numeroPayeur');
      paymentTerms.payerDivergent = getF(acoElem, 'ns:payeurDivergent');
      servicesElem = acoElem['ns:services'];
      services = servicesElem.map(function(serviceElem) {
        var service;
        service = {};
        service.name = getF(serviceElem, 'ns:nomService');
        service.status = getF(serviceElem, 'ns:etat');
        service.valueSubscribed = getF(serviceElem, 'ns:valeurSouscrite');
        service.valuesAvailable = serviceElem['ns:valeursPossibles'];
        return service;
      });
      entries.paymenttermss.push(paymentTerms);
      entries.contracts.forEach(function(contract) {
        return contract.services = contract.services.concat(services);
      });
      K.logger.info("Fetched visualiserAccordCommercial.");
      return callback();
    } catch (error1) {
      e = error1;
      K.logger.error("While fetching visualiserAccordCommercial.");
      K.logger.error(e);
      return callback(e);
    }
  });
};

fetchVisualiserCalendrierPaiement = function(requiredFields, entries, data, callback) {
  var body, path;
  K.logger.info("fetchVisualiserCalendrierPaiement");
  path = '/ws/visualiserCalendrierPaiement_rest_V2-0/invoke';
  body = {
    'message:msgRequete': {
      '$': {
        'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserCalendrierPaiement/service/v2 C:\\HMN\\" + "EDFMoiV2\\WSDL\\passerelle\\passerelle\\css\\" + "visualiserCalendrierPaiement\\service\\v2\\" + "visualiserCalendrierPaiement.xsd",
        'xmlns:message': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserCalendrierPaiement/service/v2",
        'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete",
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
      },
      'message:enteteEntree': {
        'ent:jeton': data.edfToken
      },
      'message:corpsEntree': {
        'message:numeroBp': entries.clients[0].clientId,
        'message:numeroAcc': entries.clients[0].numeroAcc
      }
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var e, errorCode, listeEcheances, paymentSchedules;
    if (err) {
      return callback(err);
    }
    try {
      errorCode = getF(result, 'ns:msgReponse', 'ns:enteteSortie', 'ent:codeRetour');
      if (errorCode && errorCode !== '0') {
        K.logger.error(getF(result, 'ns:msgReponse', 'ns:enteteSortie', 'ent:libelleRetour'));
        return callback();
      }
      listeEcheances = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:calendrierDePaiement")["ns:listeEcheances"];
      paymentSchedules = listeEcheances.map(function(echeance) {
        var amountElec, amountGaz, doc;
        amountGaz = parseFloat(getF(echeance, "ns:montantGaz"));
        amountElec = parseFloat(getF(echeance, "ns:montantElec"));
        if (isNaN(amountGaz)) {
          amountGaz = 0;
        }
        if (isNaN(amountElec)) {
          amountElec = 0;
        }
        doc = {
          number: parseInt(getF(echeance, "ns:numeroEcheance")),
          receiptDate: getF(echeance, "ns:dateEncaissement"),
          scheduleDate: getF(echeance, "ns:DateEcheance"),
          paid: getF(echeance, "ns:paiement") === 'EFFECTUE',
          amount: amountGaz + amountElec,
          amountGas: amountGaz,
          amountElectricity: amountElec
        };
        return doc;
      });
      if (!entries.paymenttermss[0]) {
        entries.paymenttermss[0] = {
          vendor: 'EDF',
          clientId: entries.clients[0].clientId,
          docTypeVersion: K.docTypeVersion
        };
      }
      entries.paymenttermss[0].paymentSchedules = paymentSchedules;
      K.logger.info(("Fetched " + paymentSchedules.length + " ") + "from fetchVisualiserCalendrierPaiement");
      return callback();
    } catch (error1) {
      e = error1;
      K.logger.error("While fetchVisualiserCalendrierPaiement");
      K.logger.error(e);
      return callback(e);
    }
  });
};

fetchRecupereDocumentContractuelListx = function(reqFields, entries, data, callback) {
  var body, path;
  K.logger.info("fetchRecupereDocumentContractuelListx");
  path = '/ws/recupererDocumentContractuelListx_rest_V1-0/invoke';
  body = {
    'ns:msgRequete': {
      '$': {
        'xmlns:dicoPAS': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/dico",
        'xmlns:dico': "http://www.edf.fr/psc/pscmaxsd/commun/v1/dico",
        'xmlns:ns': "http://www.edf.fr/commerce/passerelle/psc/" + "recupererDocumentContractuelListx/service/v1",
        'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete"
      },
      'ns:jeton': data.edfToken,
      'ns:options': [
        {
          'ns:cle': 'id',
          'ns:valeur': 'pscedfmoi'
        }, {
          'ns:cle': 2,
          'ns:valeur': entries.clients[0].clientId
        }, {
          'ns:cle': 6,
          'ns:valeur': 'Facture'
        }
      ]
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var bills, documents, e;
    if (err) {
      return callback(err);
    }
    bills = [];
    try {
      documents = result["ns:msgReponse"]["ns:docubase"][0]["ns:document"];
      bills = documents.map(function(elem) {
        var bill, date, i, key, len, option, ref, value;
        bill = {
          vendor: 'EDF',
          clientId: entries.clients[0].clientId,
          docTypeVersion: K.docTypeVersion
        };
        date = moment(getF(elem, 'ns:datecre'), 'YYYYMMDD');
        bill.date = date.format('YYYY-MM-DD');
        ref = elem['ns:category'];
        for (i = 0, len = ref.length; i < len; i++) {
          option = ref[i];
          key = getF(option, 'ns:id');
          value = getF(option, 'ns:valeur');
          switch (key) {
            case '4':
              bill.number = value;
              break;
            case '7':
              bill.amount = Number(value);
          }
        }
        return bill;
      });
      entries.bills = bills;
      K.logger.info("Fetched " + bills.length + " bills");
      return callback();
    } catch (error1) {
      e = error1;
      K.logger.error("While fetchRecupereDocumentContractuelListx");
      K.logger.error(e);
      return callback(e);
    }
  });
};

fetchVisualiserHistoConso = function(requiredFields, entries, data, callback) {
  K.logger.info("fetchVisualiserHistoConso");
  return async.mapSeries(entries.contracts, function(contract, cb) {
    var body, path;
    path = '/ws/visualiserHistoConso_rest_V3-0/invoke';
    body = {
      'message:msgRequete': {
        '$': {
          'xsi:schemaLocation': "http://www.edf.fr/commerce/" + "passerelle/css/visualiserHistoConso/service/v2 C:\\HMN" + "\\EDFMoiV2\\WSDL\\passerelle\\passerelle\\css" + "\\visualiserHistoConso\\service\\v2\\" + "visualiserHistoConso.xsd",
          'xmlns:message': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserHistoConso/service/v2",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/entete",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
        },
        'message:enteteEntree': {
          'ent:jeton': data.edfToken
        },
        'message:corpsEntree': {
          'message:numeroBp': entries.clients[0].clientId,
          'message:numeroContrat': contract.number
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var consoElems, e, errorCode, res;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleRetour'));
        }
        return callback();
        if (!("ns:corpsSortie" in result["ns:msgReponse"])) {
          K.logger.info("No histoConsos to fetch");
          return callback(null, []);
        }
        consoElems = result["ns:msgReponse"]["ns:corpsSortie"][0]["ns:listeHistoDeConso"];
        res = consoElems.map(function(consoElem) {
          var doc;
          doc = {
            contractNumber: contract.number,
            billNumber: getF(consoElem, 'ns:numeroFacture'),
            start: getF(consoElem, 'ns:dateDebut'),
            end: getF(consoElem, 'ns:dateFin'),
            value: getF(consoElem, 'ns:listeConsommation', 'ns:valeur'),
            statementType: getF(consoElem, 'ns:typeReleve'),
            statementCategory: getF(consoElem, 'ns:categorieReleve'),
            statementReason: getF(consoElem, 'ns:motifReleve'),
            docTypeVersion: K.docTypeVersion
          };
          return doc;
        });
        return cb(null, res);
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching visualiserHistoConso.");
        K.logger.error(e);
        return cb(e);
      }
    });
  }, function(err, results) {
    if (err) {
      return callback(err);
    }
    entries.consumptionstatements = results.reduce(function(agg, result) {
      return agg.concat(result);
    }, []);
    K.logger.info(("Fetched " + entries.consumptionstatements.length) + " consumptionStatements");
    return callback();
  });
};

fetchPDF = function(token, client, billNumber, callback) {
  var body, path;
  K.logger.info("fetchPDF");
  path = '/ws/recupererDocumentContractuelGet_rest_V1-0/invoke';
  body = {
    'ns:msgRequete': {
      '$': {
        'xmlns:dicoPAS': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/dico",
        'xmlns:dico': "http://www.edf.fr/psc/pscmaxsd/commun/v1/dico",
        'xmlns:ns': "http://www.edf.fr/commerce/passerelle/psc/" + "recupererDocumentContractuelGet/service/v1",
        'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete"
      },
      'ns:jeton': token,
      'ns:options': [
        {
          'ns:cle': 'id',
          'ns:valeur': 'pscedfmoi'
        }, {
          'ns:cle': 2,
          'ns:valeur': client.clientId
        }, {
          'ns:cle': 4,
          'ns:valeur': billNumber
        }, {
          'ns:cle': 6,
          'ns:valeur': 'Facture'
        }
      ]
    }
  };
  return edfRequestPost(path, body, function(err, result) {
    var base64PDF;
    if (err) {
      return callback(err);
    }
    K.logger.info("pdf fetched");
    base64PDF = getF(result['ns:msgReponse'], 'ns:docubase', 'ns:documentPDF', 'ns:pdf');
    return callback(null, base64PDF);
  });
};

fetchEdeliaToken = function(requiredFields, entries, data, callback) {
  K.logger.info("fetchEdeliaToken");
  return request.post('https://api.edelia.fr/authorization-server/oauth/token', {
    form: {
      client_id: 'sha1pae0Pahngee6uwiphooDie7thaiquahf2xohd6IeFeiphi9ziu0uw3am',
      grant_type: 'edf_sso',
      jeton_sso: data.edfToken,
      bp: entries.clients[0].clientId,
      pdl: data.contract.pdl
    },
    json: true
  }, function(err, response, result) {
    if (err) {
      K.logger.error('While fetching edelia token.');
      K.logger.error(err);
      return callback(err);
    }
    K.logger.info('Fetched edelia token');
    data.edeliaToken = result.access_token;
    return callback();
  });
};

fetchEdeliaProfile = function(requiredFields, entries, data, callback) {
  K.logger.info("fetchEdeliaMonthlyProfile");
  return getEdelia(data.edeliaToken, '/sites/-/profiles/simple?ts=' + new Date().toISOString(), function(err, response, obj) {
    var doc, e, error;
    error = null;
    try {
      if (!err && !obj) {
        err = 'no import performed';
      }
      if (err) {
        K.logger.error('While fetchEdeliaProfile');
        K.logger.error(err);
        throw err;
      }
      if (obj.errorCode && obj.errorCode === "403") {
        data.noEdelia = true;
        K.logger.warn("No edelia: " + obj.errorDescription);
        throw new Error('no edelia');
      }
      doc = {
        pdl: data.pdl,
        beginTs: obj.beginTs,
        isProfileValidated: obj.isProfileValidated,
        housingType: obj.housingType,
        residenceType: obj.residenceType,
        occupationType: obj.occupationType,
        constructionDate: obj.constructionDate,
        isBBC: obj.isBBC,
        surface: obj.surfaceInSqMeter,
        occupantsCount: obj.noOfOccupants,
        principalHeatingSystemType: obj.principalHeatingSystemType,
        sanitoryHotWaterType: obj.sanitoryHotWaterType,
        docTypeVersion: K.docTypeVersion
      };
      entries.homes.push(doc);
      return K.logger.info('Fetched fetchEdeliaProfile');
    } catch (error1) {
      e = error1;
      return error = e;
    } finally {
      callback(error);
    }
  });
};

fetchEdeliaMonthlyElecConsumptions = function(requiredFields, entries, data, callback) {
  if (data.noEdelia) {
    return callback();
  }
  K.logger.info("fetchEdeliaMonthlyElecConsumptions");
  return getEdelia(data.edeliaToken, "/sites/-/monthly-elec-consumptions?" + "begin-month=2012-01&" + ("end-month=" + (moment().add(1, 'month').format('YYYY-MM')) + "&ended=false"), function(err, response, obj) {
    var e, error, statements;
    error = null;
    try {
      if (response.statusCode === 404 || response.statusCode === 500) {
        K.logger.warn('No EdeliaMonthlyElecConsumptions');
        data.noElec = true;
        throw null;
      }
      if (err) {
        K.logger.error('Wihle fetchEdeliaMonthlyElecConsumptions');
        K.logger.error(err);
        throw err;
      }
      statements = [];
      data.consumptionStatementByMonth = {};
      statements = statements.concat(obj.monthlyElecEnergies.map(function(mee) {
        var doc;
        doc = {
          docTypeVersion: K.docTypeVersion,
          contractNumber: data.contract.number,
          start: mee.beginDay,
          end: mee.endDay,
          value: mee.consumption.energy,
          statementType: 'estime',
          statementCategory: 'edelia',
          statementReason: 'EdeliaMonthlyElecConsumption',
          period: mee.month,
          cost: mee.totalCost,
          costsByCategory: mee.consumption.costsByTariffHeading,
          valuesByCatergory: mee.consumption.energiesByTariffHeading
        };
        doc.costsByCategory.standing = mee.standingCharge;
        data.consumptionStatementByMonth[mee.month] = doc;
        return doc;
      }));
      data.consumptionStatementByYear = {};
      statements = statements.concat(obj.yearlyElecEnergies.map(function(yee) {
        var doc;
        doc = {
          docTypeVersion: K.docTypeVersion,
          contractNumber: data.contract.number,
          start: yee.beginDay,
          end: yee.endDay,
          value: yee.consumption.energy,
          statementType: 'estime',
          statementCategory: 'edelia',
          statementReason: 'EdeliaYearlyElecConsumption',
          period: yee.year,
          cost: yee.totalCost,
          costsByCategory: yee.consumption.costsByTariffHeading,
          valuesByCatergory: yee.consumption.energiesByTariffHeading
        };
        doc.costsByCategory.standing = yee.standingCharge;
        data.consumptionStatementByYear[yee.year] = doc;
        return doc;
      }));
      if (statements.length !== 0) {
        entries.consumptionstatements = entries.consumptionstatements.concat(statements);
      }
      return K.logger.info('Fetched fetchEdeliaMonthlyElecConsumptions');
    } catch (error1) {
      e = error1;
      return error = e;
    } finally {
      callback(error);
    }
  });
};

fetchEdeliaSimilarHomeYearlyElecComparisions = function(requiredFields, entries, data, callback) {
  if (data.noEdelia || data.noElec) {
    return callback();
  }
  K.logger.info("fetchEdeliaSimilarHomeYearlyElecComparisions");
  return getEdelia(data.edeliaToken, "/sites/-/similar-home-yearly-elec-comparisons?begin-year=2012", function(err, response, objs) {
    var e, error;
    error = null;
    try {
      if (response.statusCode === 404 || response.statusCode === 500) {
        K.logger.warn('No EdeliaSimilarHomeYearlyElecComparisions');
        data.noElec = true;
        throw null;
      }
      if (err) {
        K.logger.error('While fetchEdeliaSimilarHomeYearlyElecComparisions');
        K.logger.error(err);
        throw err;
      }
      objs.forEach(function(obj) {
        var statement;
        statement = data.consumptionStatementByYear[obj.year];
        if (!statement) {
          K.logger.warn("No yearly statement for " + obj.date.year);
          return;
        }
        return statement.similarHomes = {
          site: obj.energies.site,
          average: obj.energies.similarHomes.SH_AVERAGE_CONSUMING,
          least: obj.energies.similarHomes.SH_LEAST_CONSUMING
        };
      });
      K.logger.info('Fetched fetchEdeliaSimilarHomeYearlyElecComparisions');
    } catch (error1) {
      e = error1;
      error = e;
    }
    delete data.consumptionStatementByYear;
    return callback(error);
  });
};

fetchEdeliaElecIndexes = function(requiredFields, entries, data, callback) {
  if (data.noEdelia || data.noElec) {
    return callback();
  }
  K.logger.info("fetchEdeliaElecIndexes");
  return getEdelia(data.edeliaToken, "/sites/-/elec-indexes?begin-date=2012-01-01&" + ("end-date=" + (moment().format('YYYY-MM-DD')) + "&types="), function(err, response, objs) {
    var e, error;
    error = null;
    try {
      if (response.statusCode === 404) {
        K.logger.warn('No EdeliaElecIndexes');
        throw null;
      }
      if (err) {
        K.logger.error('Wihle fetchEdeliaElecIndexes');
        K.logger.error(err);
        throw err;
      }
      objs.forEach(function(obj) {
        var statement;
        statement = data.consumptionStatementByMonth[obj.date.slice(0, 7)];
        if (!statement) {
          K.logger.warn("No monthly statement for" + (obj.date.slice(0, 7)));
          return;
        }
        statement.statements = statement.statements || [];
        return statement.statements.push(obj);
      });
      K.logger.info('Fetched fetchEdeliaElecIndexes');
    } catch (error1) {
      e = error1;
      error = e;
    }
    delete data.consumptionStatementByMonth;
    return callback(error);
  });
};

fetchEdeliaMonthlyGasConsumptions = function(requiredFields, entries, data, callback) {
  if (data.noEdelia) {
    return callback();
  }
  K.logger.info("fetchEdeliaMonthlyGasConsumptions");
  return getEdelia(data.edeliaToken, "/sites/-/monthly-gas-consumptions?begin-month=2012-01&" + ("end-month=" + (moment().add(1, 'month').format('YYYY-MM')) + "&ended=false"), function(err, response, obj) {
    var e, error, ref, statements;
    error = null;
    try {
      if (response.statusCode === 404) {
        K.logger.warn('No EdeliaMonthlyGasConsumptions');
        data.noGas = true;
        throw null;
      }
      if (err) {
        K.logger.error('Wihle fetchEdeliaMonthlyGasConsumptions');
        K.logger.error(err);
        throw err;
      }
      statements = [];
      data.consumptionStatementByMonth = {};
      statements = (ref = obj.monthlyGasEnergies) != null ? ref.map(function(mee) {
        var doc;
        doc = {
          docTypeVersion: K.docTypeVersion,
          contractNumber: data.contract.number,
          start: mee.beginDay,
          end: mee.endDay,
          value: mee.consumption.energy,
          statementType: 'estime',
          statementCategory: 'edelia',
          statementReason: 'EdeliaMonthlyGasConsumption',
          period: mee.month,
          cost: mee.totalCost,
          costsByCategory: {
            consumption: mee.consumption.cost,
            standing: mee.standingCharge
          }
        };
        data.consumptionStatementByMonth[mee.month] = mee;
        return doc;
      }) : void 0;
      data.consumptionStatementByYear = {};
      statements = statements.concat(obj.yearlyGasEnergies.map(function(yee) {
        var doc;
        doc = {
          docTypeVersion: K.docTypeVersion,
          contractNumber: data.contract.number,
          start: yee.beginDay,
          end: yee.endDay,
          value: yee.consumption.energy,
          statementType: 'estime',
          statementCategory: 'edelia',
          statementReason: 'EdeliaYearlyGasConsumption',
          period: yee.year,
          cost: yee.totalCost,
          costsByCategory: {
            consumption: yee.consumption.cost,
            standing: yee.standingCharge
          }
        };
        data.consumptionStatementByYear[yee.year] = doc;
        return doc;
      }));
      if (statements.length !== 0) {
        entries.consumptionstatements = entries.consumptionstatements.concat(statements);
      }
      K.logger.info('Fetched fetchEdeliaMonthlyGasConsumptions');
    } catch (error1) {
      e = error1;
      error = e;
    }
    return callback(error);
  });
};

fetchEdeliaSimilarHomeYearlyGasComparisions = function(requiredFields, entries, data, callback) {
  if (data.noEdelia || data.noGas) {
    return callback();
  }
  K.logger.info("fetchEdeliaSimilarHomeYearlyGasComparisions");
  return getEdelia(data.edeliaToken, "/sites/-/similar-home-yearly-gas-comparisons?begin-year=2012", function(err, response, objs) {
    var e, error;
    error = null;
    try {
      if (response.statusCode === 404 || response.statusCode === 500) {
        K.logger.warn('No EdeliaSimilarHomeYearlyGasComparisions');
        throw null;
      }
      if (err) {
        K.logger.error('While fetchEdeliaSimilarHomeYearlyGasComparisions');
        K.logger.error(err);
        throw err;
      }
      objs.forEach(function(obj) {
        var statement;
        statement = data.consumptionStatementByYear[obj.year];
        if (!statement) {
          K.logger.warn("No yearly statement for " + obj.date.year);
          return;
        }
        return statement.similarHomes = {
          site: obj.energies.site,
          average: obj.energies.similarHomes.SH_AVERAGE_CONSUMING,
          least: obj.energies.similarHomes.SH_LEAST_CONSUMING
        };
      });
      K.logger.info('Fetched fetchEdeliaSimilarHomeYearlyGasComparisions');
    } catch (error1) {
      e = error1;
      error = e;
    }
    return callback(error);
  });
};

fetchEdeliaGasIndexes = function(requiredFields, entries, data, callback) {
  if (data.noEdelia || data.noGas) {
    return callback();
  }
  K.logger.info("fetchEdeliaGasIndexes");
  return getEdelia(data.edeliaToken, "/sites/-/gas-indexes?begin-date=2012-01-01&" + ("end-date=" + (moment().format('YYYY-MM-DD')) + "&types="), function(err, response, objs) {
    var e, error;
    error = null;
    try {
      if (response.statusCode === 404) {
        K.logger.warn('No EdeliaGasIndexes');
        throw null;
      }
      if (err) {
        K.logger.error('Wihle fetchEdeliaGasIndexes');
        K.logger.error(err);
        throw err;
      }
      objs.forEach(function(obj) {
        var statement;
        statement = data.consumptionStatementByMonth[obj.date.slice(0, 7)];
        if (!statement) {
          K.logger.warn("No monthly statement for" + (obj.date.slice(0, 7)));
          return;
        }
        statement.statements = statement.statements || [];
        return statement.statements.push(obj);
      });
      K.logger.info('Fetched fetchEdeliaGasIndexes');
    } catch (error1) {
      e = error1;
      error = e;
    }
    return callback(error);
  });
};

prepareEntries = function(requiredFields, entries, data, next) {
  entries.homes = [];
  entries.consumptionstatements = [];
  entries.contracts = [];
  entries.bills = [];
  entries.clients = [];
  entries.paymenttermss = [];
  return next();
};

buildNotifContent = function(requiredFields, entries, data, next) {
  var addedList, count, docsName, message, ref;
  addedList = [];
  ref = data.created;
  for (docsName in ref) {
    count = ref[docsName];
    if (count > 0) {
      message = localization.t("notification " + docsName, {
        smart_count: count
      });
      addedList.push(message);
    }
  }
  entries.notifContent = addedList.join(', ');
  return next();
};

createNewFile = function(data, file, callback) {
  var attachBinary;
  attachBinary = function(newFile) {
    file.path = data.name;
    return newFile.attachBinary(file, {
      "name": "file"
    }, function(err, res, body) {
      var upload;
      upload = false;
      if (err) {
        return newFile.destroy(function(error) {
          return callback('file error');
        });
      } else {
        return callback(null, newFile);
      }
    });
  };
  return File.create(data, function(err, newFile) {
    if (err) {
      K.logger.error(err);
      return callback('file error');
    } else {
      return attachBinary(newFile);
    }
  });
};

saveMissingBills = function(requiredFields, entries, data, callback) {
  return Bill.all(function(err, bills) {
    return async.eachSeries(bills, function(bill, cb) {
      if ((bill.vendor !== 'EDF') || bill.fileId) {
        return cb();
      }
      return fetchPDF(data.edfToken, entries.clients[0], bill.number, function(err, base64String) {
        var binaryBill, file, name;
        if (err) {
          return cb(err);
        }
        binaryBill = new Buffer(base64String, 'base64');
        name = (moment(bill.date).format('YYYY-MM')) + "-factureEDF.pdf";
        file = new File({
          name: name,
          mime: "application/pdf",
          creationDate: new Date().toISOString(),
          lastModification: new Date().toISOString(),
          "class": "document",
          path: requiredFields.folderPath,
          size: binaryBill.length
        });
        return Folder.mkdirp(requiredFields.folderPath, function(err) {
          if (err) {
            return cb('file error');
          }
          return createNewFile(file, binaryBill, function(err, file) {
            var ref;
            if (err) {
              return cb('file error');
            }
            return bill.updateAttributes({
              fileId: file._id,
              binaryId: (ref = file.binary) != null ? ref.file.id : void 0
            }, cb);
          });
        });
      });
    }, callback);
  });
};

displayData = function(requiredFields, entries, data, next) {
  K.logger.info("display data");
  K.logger.info(JSON.stringify(entries, null, 2));
  K.logger.info(JSON.stringify(data, null, 2));
  return next();
};

fetchEdeliaData = function(requiredFields, entries, data, next) {
  return async.eachSeries(entries.contracts, function(contract, callback) {
    var importer, operations;
    data.contract = contract;
    importer = fetcher["new"]();
    operations = [fetchEdeliaToken, fetchEdeliaProfile, fetchEdeliaMonthlyElecConsumptions, fetchEdeliaSimilarHomeYearlyElecComparisions, fetchEdeliaElecIndexes, fetchEdeliaMonthlyGasConsumptions, fetchEdeliaSimilarHomeYearlyGasComparisions, fetchEdeliaGasIndexes];
    operations.forEach(function(operation) {
      return importer.use(operation);
    });
    importer.args(requiredFields, entries, data);
    return importer.fetch(function(err, fields, entries) {
      if (err) {
        K.logger.error('Error while fetching Edelia data');
        K.logger.error(err);
      }
      return callback();
    });
  }, next);
};

K = module.exports = require('../lib/base_konnector').createNew({
  name: 'EDF',
  slug: 'edf',
  description: 'konnector description edf',
  vendorLink: 'https://particulier.edf.fr',
  fields: {
    email: 'text',
    password: 'password',
    folderPath: 'folder'
  },
  models: [Client, Contract, PaymentTerms, Home, ConsumptionStatement, Bill],
  fetchOperations: [prepareEntries, getEDFToken, fetchListerContratClientParticulier, fetchVisualiserPartenaire, fetchVisualiserAccordCommercial, fetchVisualiserCalendrierPaiement, fetchRecupereDocumentContractuelListx, fetchVisualiserHistoConso, fetchEdeliaData, updateOrCreate(logger, Client, ['clientId', 'vendor']), updateOrCreate(logger, Contract, ['number', 'vendor']), updateOrCreate(logger, PaymentTerms, ['vendor', 'clientId']), updateOrCreate(logger, Home, ['pdl']), updateOrCreate(logger, ConsumptionStatement, ['contractNumber', 'statementType', 'statementReason', 'statementCategory', 'start']), updateOrCreate(logger, Bill, ['vendor', 'number']), saveMissingBills, buildNotifContent]
});

_extend = function(a, b) {
  var k, v;
  for (k in b) {
    v = b[k];
    if (v != null) {
      a[k] = v;
    }
  }
  return a;
};

getF = function() {
  var e, field, fields, i, len, node;
  node = arguments[0], fields = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  try {
    for (i = 0, len = fields.length; i < len; i++) {
      field = fields[i];
      node = node[field][0];
    }
  } catch (error1) {
    e = error1;
    return null;
  }
  return node;
};

translate = function(dict, name) {
  if (name in dict) {
    return dict[name];
  }
  return name;
};

edfRequestPost = function(path, body, callback) {
  return async.retry({
    times: 5,
    interval: 2000
  }, function(cb) {
    return _edfRequestPost(path, body, cb);
  }, callback);
};

_edfRequestPost = function(path, body, callback) {
  var xmlBody;
  K.logger.debug("called edfRequestPost");
  xmlBody = builder.buildObject(body);
  return request({
    url: 'https://rce-mobile.edf.com' + path,
    method: 'POST',
    headers: {
      'Host': 'rce-mobile.edf.com',
      'Content-Type': 'application/xml',
      'Authorization': 'Basic ' + 'QUVMTU9CSUxFX0FuZHJvaWRfVjE6QUVMTU9CSUxFX0FuZHJvaWRfVjE=',
      'Accept-Encoding': 'gzip',
      'Content-Length': xmlBody.length
    },
    body: xmlBody,
    gzip: true
  }, function(err, response, data) {
    if (err) {
      K.logger.error(JSON.stringify(err));
    }
    if (err) {
      return callback('request error');
    }
    return parser.parseString(data, function(err, result) {
      if (err) {
        return callback('request error');
      }
      return callback(null, result);
    });
  });
};

getEdelia = function(accessToken, path, callback) {
  return request.get('https://api.edelia.fr/authorization-proxy/api/v1/' + path, {
    auth: {
      bearer: accessToken
    },
    json: true
  }, callback);
};
