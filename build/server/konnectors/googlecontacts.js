// Generated by CoffeeScript 1.10.0
var ACCOUNT_TYPE, CompareContacts, Contact, ContactHelper, GoogleContactHelper, GoogleToken, Tag, async, deleteInGoogle, extend, fetchAccountName, fetchAllGoogleContacts, fetchGoogleChanges, fetcher, localization, log, prepareCozyContacts, removeFromCozyContact, request, saveTokensInKonnector, updateCozyContacts, updateGoogleContact, updateGoogleContacts, updateToken;

request = require('request');

async = require('async');

fetcher = require('../lib/fetcher');

extend = require('util')._extend;

Contact = require('../models/contact');

Tag = require('../models/tag');

CompareContacts = require('../lib/compare_contacts');

ContactHelper = require('../lib/contact_helper');

GoogleContactHelper = require('../lib/google_contact_helper');

GoogleToken = require('../lib/google_access_token');

localization = require('../lib/localization_manager');

log = require('printit')({
  prefix: "Google Contacts",
  date: true
});

ACCOUNT_TYPE = 'com.google';

module.exports = {
  name: "Google Contacts",
  slug: "googlecontacts",
  description: 'konnector description googlecontacts',
  vendorLink: "https://www.google.com/contacts/",
  customView: "<h6><%t konnector customview googlecontacts 4 %></h6>\n<p><%t konnector customview googlecontacts 1 %></p>\n<button id=\"connect-google\"\ntitle=\"<%t konnector customview googlecontacts 2 %>\" class=\"btn\"\n   onclick=\"window.open('" + (GoogleToken.getAuthUrl()) + "',\n   'Google OAuth',\n   'toolbars=0,width=700,height=600,left=200,top=200,scrollbars=1,resizable=1');\n   var input = $('#googlecontacts-authCode0-input');\n   input.parents('.field').toggleClass('hidden');\n   input.attr('type', 'text');\n   input.val('');\n   $('#googlecontacts-accountName-input').text('--');\n   return false;\"\n   ><%t konnector customview googlecontacts 2 %></button>\n<p><%t konnector customview googlecontacts 3 %></p>",
  fields: {
    authCode: "hidden",
    accountName: "label",
    accessToken: "hidden",
    refreshToken: "hidden"
  },
  models: {
    contact: Contact
  },
  init: function(callback) {
    return callback();
  },
  fetch: function(requiredFields, callback) {
    log.info("Import started");
    return fetcher["new"]().use(updateToken).use(fetchAccountName).use(saveTokensInKonnector).use(fetchGoogleChanges).use(prepareCozyContacts).use(updateCozyContacts).args(requiredFields, {}, {}).fetch(function(err, fields, entries) {
      if (err) {
        return callback(err);
      }
      log.info("Import finished");
      return callback();
    });
  }
};

module.exports.updateToken = updateToken = function(requiredFields, entries, data, callback) {
  log.debug('updateToken');
  if ((requiredFields.refreshToken != null) && requiredFields.authCode === 'connected') {
    return GoogleToken.refreshToken(requiredFields.refreshToken, function(err, tokens) {
      if (err) {
        log.info(err);
        return callback('token not found');
      }
      requiredFields.accessToken = tokens.access_token;
      return callback();
    });
  } else {
    return GoogleToken.generateRequestToken(requiredFields.authCode, function(err, tokens) {
      if (err) {
        log.info(err);
        return callback('token not found');
      }
      requiredFields.accessToken = tokens.access_token;
      requiredFields.refreshToken = tokens.refresh_token;
      requiredFields.authCode = 'connected';
      requiredFields.accountName = null;
      requiredFields.lastSuccess = null;
      return callback();
    });
  }
};

fetchAccountName = function(requiredFields, entries, data, callback) {
  log.debug('fetchAccountName');
  if ((requiredFields.accountName != null) && requiredFields.accountName.indexOf('@') !== -1) {
    return callback();
  }
  return GoogleContactHelper.fetchAccountName(requiredFields.accessToken, function(err, accountName) {
    if (err) {
      log.info(err);
      return callback('request error');
    }
    requiredFields.accountName = accountName;
    return callback();
  });
};

saveTokensInKonnector = function(requiredFields, entries, data, callback) {
  var Konnector;
  log.debug('saveTokensInKonnector');
  Konnector = require('../models/konnector');
  return Konnector.all(function(err, konnectors) {
    var accounts, konnector;
    if (err) {
      log.info(err);
      return callback('request error');
    }
    konnector = konnectors.filter(function(k) {
      return k.slug === 'googlecontacts';
    })[0];
    accounts = [
      {
        accountName: requiredFields.accountName,
        accessToken: requiredFields.accessToken,
        refreshToken: requiredFields.refreshToken,
        authCode: requiredFields.authCode
      }
    ];
    return konnector.updateAttributes({
      accounts: accounts
    }, callback);
  });
};

fetchGoogleChanges = function(requiredFields, entries, data, callback) {
  var uri;
  log.debug('fetchGoogleChanges');
  uri = "https://www.google.com";
  uri += "/m8/feeds/contacts/" + requiredFields.accountName + "/full/";
  uri += "?alt=json&showdeleted=true&max-results=10000";
  if (requiredFields.lastSuccess != null) {
    uri += "&updated-min=" + (requiredFields.lastSuccess.toISOString());
  }
  log.debug("fetch " + uri);
  return request({
    method: 'GET',
    uri: uri,
    json: true,
    headers: {
      'Authorization': 'Bearer ' + requiredFields.accessToken,
      'GData-Version': '3.0'
    }
  }, function(err, res, body) {
    var ref;
    if (err) {
      log.info(err);
      return callback('request error');
    }
    if (body.error) {
      log.info("Error while fetching google changes : ");
      log.info(body);
      return callback('request error');
    }
    entries.googleChanges = ((ref = body.feed) != null ? ref.entry : void 0) || [];
    return callback();
  });
};

updateCozyContacts = function(requiredFields, entries, data, callback) {
  log.debug('updateCozyContacts');
  return async.mapSeries(entries.googleChanges, function(gEntry, cb) {
    if (gEntry.gd$deleted != null) {
      return removeFromCozyContact(gEntry, entries.ofAccountByIds, requiredFields.accountName, cb);
    } else {
      return GoogleContactHelper.updateCozyContact(gEntry, entries, requiredFields.accountName, requiredFields.accessToken, cb);
    }
  }, function(err, updated) {
    if (err) {
      log.info(err);
      return callback('request error');
    }
    if (updated.some(function(contact) {
      return contact != null;
    })) {
      return Tag.getOrCreate({
        name: 'google',
        color: '#4285F4'
      }, callback);
    } else {
      return callback();
    }
  });
};

removeFromCozyContact = function(gEntry, ofAccountByIds, accountName, callback) {
  var accounts, contact, id, tags;
  id = GoogleContactHelper.extractGoogleId(gEntry);
  contact = ofAccountByIds[id];
  if (contact != null) {
    log.debug("Unlink " + id + " " + (contact != null ? contact.fn : void 0) + " from this account");
    log.info("Unlink " + id + " from this account");
    accounts = contact.accounts.filter(function(account) {
      return !(account.type === ACCOUNT_TYPE && account.name === accountName);
    });
    tags = contact.tags.filter(function(tag) {
      return tag !== "google";
    });
    return contact.updateAttributes({
      tags: tags,
      accounts: accounts
    }, callback);
  } else {
    log.info("Contact " + id + " already unlinked from this account.");
    return callback();
  }
};

fetchAllGoogleContacts = function(requiredFields, entries, data, callback) {
  var uri;
  log.debug('fetchAllGoogleContacts');
  uri = "https://www.google.com";
  uri += "/m8/feeds/contacts/" + requiredFields.accountName + "/full/";
  uri += "?alt=json&max-results=10000";
  return request({
    method: 'GET',
    uri: uri,
    json: true,
    headers: {
      'Authorization': 'Bearer ' + requiredFields.accessToken,
      'GData-Version': '3.0'
    }
  }, function(err, res, body) {
    var gEntry, i, id, len, ref, ref1;
    if (err) {
      log.info(err);
      return callback('request error');
    }
    if (body.error != null) {
      log.info(body.error);
      return callback('request error');
    }
    entries.googleContacts = ((ref = body.feed) != null ? ref.entry : void 0) || [];
    entries.googleContactsById = {};
    ref1 = entries.googleContacts;
    for (i = 0, len = ref1.length; i < len; i++) {
      gEntry = ref1[i];
      id = GoogleContactHelper.extractGoogleId(gEntry);
      entries.googleContactsById[id] = gEntry;
    }
    return callback();
  });
};

prepareCozyContacts = function(requiredFields, entries, data, callback) {
  log.debug('prepareCozyContacts');
  return Contact.all(function(err, contacts) {
    var account, contact, i, len;
    if (err) {
      log.info(err);
      return callback('request error');
    }
    entries.cozyContacts = contacts;
    entries.ofAccount = [];
    entries.ofAccountByIds = {};
    for (i = 0, len = contacts.length; i < len; i++) {
      contact = contacts[i];
      account = contact.getAccount(ACCOUNT_TYPE, requiredFields.accountName);
      if (account != null) {
        entries.ofAccountByIds[account.id] = contact;
        entries.ofAccount.push(contact);
      }
    }
    return callback();
  });
};

updateGoogleContacts = function(requiredFields, entries, data, callback) {
  var googleContactsById;
  log.debug('updateGoogleContacts');
  googleContactsById = extend({}, entries.googleContactsById);
  return async.eachSeries(entries.ofAccount, function(contact, cb) {
    var account, gEntry;
    account = contact.getAccount(ACCOUNT_TYPE, requiredFields.accountName);
    gEntry = googleContactsById[account.id];
    delete googleContactsById[account.id];
    if (account.lastUpdate < contact.revision) {
      return updateGoogleContact(requiredFields, contact, gEntry, cb);
    } else {
      return cb();
    }
  }, function(err) {
    var toDelete;
    toDelete = Object.keys(googleContactsById);
    if (toDelete.length === 0) {
      return callback();
    }
    log.info("delete " + toDelete.length + " contacts in google");
    return async.eachSeries(toDelete, function(gId, cb) {
      return deleteInGoogle(requiredFields, gId, cb);
    }, callback);
  });
};

updateGoogleContact = function(requiredFields, contact, gEntry, callback) {
  var account, fromGoogle, updated, uri;
  account = contact.getAccount(ACCOUNT_TYPE, requiredFields.accountName);
  fromGoogle = new Contact(GoogleContactHelper.fromGoogleContact(gEntry));
  if (ContactHelper.intrinsicRev(fromGoogle) !== ContactHelper.intrinsicRev(contact)) {
    log.debug(ContactHelper.intrinsicRev(contact));
    log.debug(ContactHelper.intrinsicRev(fromGoogle));
    log.debug("update " + (contact != null ? contact.fn : void 0) + " in google");
    log.info("update " + (contact != null ? contact._id : void 0) + " in google");
    updated = GoogleContactHelper.toGoogleContact(contact, gEntry);
    uri = "https://www.google.com";
    uri += "/m8/feeds/contacts/" + account.name + "/full/" + account.id + "/";
    uri += "?alt=json";
    return request({
      method: 'PUT',
      uri: uri,
      json: true,
      body: {
        entry: updated
      },
      headers: {
        'Authorization': 'Bearer ' + requiredFields.accessToken,
        'GData-Version': '3.0',
        'If-Match': '*'
      }
    }, function(err, res, body) {
      if (err) {
        log.info(err);
        return callback('request error');
      }
      log.debug(body);
      if (body.error != null) {
        log.warn('Error while uploading contact to google');
        log.warn(body);
        return callback();
      } else {
        return GoogleContactHelper.putPicture2Google(requiredFields.accessToken, account, contact, callback);
      }
    });
  } else {
    return callback();
  }
};

deleteInGoogle = function(requiredFields, gId, callback) {
  var uri;
  uri = "https://www.google.com";
  uri += "/m8/feeds/contacts/" + requiredFields.accountName + "/full/" + gId + "/";
  return request({
    method: 'DELETE',
    uri: uri,
    json: true,
    headers: {
      'Authorization': 'Bearer ' + requiredFields.accessToken,
      'GData-Version': '3.0',
      'If-Match': '*'
    }
  }, function(err, res, body) {
    if (err) {
      log.info(err);
      return callback('request error');
    }
    return callback();
  });
};
