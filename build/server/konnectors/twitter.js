// Generated by CoffeeScript 1.9.3
var TwitterTweet, async, cozydb, localization, log, moment, querystring, request, requestJson, saveTweetGroup, saveTweets;

cozydb = require('cozydb');

querystring = require('querystring');

requestJson = require('request-json');

request = require('request');

moment = require('moment');

async = require('async');

log = require('printit')({
  prefix: "Twitter",
  date: true
});

localization = require('../lib/localization_manager');

TwitterTweet = cozydb.getModel('TwitterTweet', {
  date: Date,
  id_str: String,
  text: String,
  retweetCount: Number,
  favoriteCount: Number,
  isReplyTo: Boolean,
  isRetweet: Boolean
});

TwitterTweet.all = function(callback) {
  return TwitterTweet.request('byDate', callback);
};

module.exports = {
  name: "Twitter",
  slug: "twitter",
  description: 'konnector description twitter',
  vendorLink: "https://twitter.com/",
  fields: {
    consumerKey: "text",
    consumerSecret: "password",
    accessToken: "text",
    accessTokenSecret: "password"
  },
  models: {
    tweets: TwitterTweet
  },
  modelNames: ["TwitterTweet"],
  init: function(callback) {
    var map;
    map = function(doc) {
      return emit(doc.date, doc);
    };
    return TwitterTweet.defineRequest('byDate', map, function(err) {
      return callback(err);
    });
  },
  fetch: function(requiredFields, callback) {
    log.info("Import started");
    return saveTweets(requiredFields, callback);
  }
};

saveTweets = function(requiredFields, callback) {
  var client, params, path, rootPath, url;
  url = "https://api.twitter.com/1.1/";
  client = requestJson.newClient(url);
  client.options = {
    oauth: {
      consumer_key: requiredFields["consumerKey"],
      consumer_secret: requiredFields["consumerSecret"],
      token: requiredFields["accessToken"],
      token_secret: requiredFields["accessTokenSecret"]
    }
  };
  rootPath = "statuses/user_timeline.json?";
  path = rootPath + querystring.stringify({
    trim_user: true,
    exclude_replies: true,
    contributor_details: false,
    count: 200
  });
  params = {
    descending: true
  };
  return TwitterTweet.request('byDate', params, function(err, tweets) {
    var start;
    if ((tweets.length != null) && tweets.length > 0) {
      start = moment(tweets[0].date);
    } else {
      start = moment().subtract('years', 10);
    }
    log.info("Start import since " + (start.format()));
    return saveTweetGroup(client, path, start, tweets.length, function(err, numItems) {
      var localizationKey, notifContent, options;
      if (err) {
        return callback(err);
      } else {
        log.info("Import finished");
        notifContent = null;
        if (numItems > 0) {
          localizationKey = 'notification twitter';
          options = {
            smart_count: numItems
          };
          notifContent = localization.t(localizationKey, options);
        }
        return callback(null, notifContent);
      }
    });
  });
};

saveTweetGroup = function(client, path, start, tweetLength, callback) {
  return client.get(path, function(err, res, tweets) {
    var numItems;
    log.debug(tweetLength + " tweet in DB, " + tweets.length + " in the response");
    if (err) {
      return callback(err);
    } else if (res.statusCode !== 200) {
      log.error('Authentication error');
      return callback('bad credentials');
    } else if (tweetLength === tweets.length) {
      log.info('No new tweet to import');
      return callback(null, 0);
    } else {
      log.info((tweets.length - tweetLength) + " tweet(s) to import");
      tweets = tweets.reverse();
      if (path.indexOf('max_id') !== -1) {
        tweets.pop();
      }
      numItems = 0;
      return async.eachSeries(tweets, function(tweet, cb) {
        var date, twitterTweet;
        date = moment(tweet.created_at);
        log.debug(date);
        if (date > start) {
          twitterTweet = {
            date: date,
            text: tweet.text,
            id_str: tweet.id_str,
            retweetCount: tweet.retweet_count,
            favoriteCount: tweet.favorite_count,
            isReplyTo: tweet.in_reply_to_status_id != null,
            isRetweet: tweet.retweeted_status != null
          };
          numItems++;
          return TwitterTweet.create(twitterTweet, function(err) {
            if (err) {
              return cb(err);
            } else {
              log.debug('tweet saved ' + date);
              return cb();
            }
          });
        } else {
          return cb();
        }
      }, function(err) {
        return callback(err, numItems);
      });
    }
  });
};
