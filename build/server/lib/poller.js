// Generated by CoffeeScript 1.11.1
var Konnector, KonnectorPoller, async, day, format, fs, hour, importer, konnectorHash, log, moment, month, path, periods, week;

async = require("async");

moment = require("moment");

fs = require('fs');

path = require('path');

log = require('printit')({
  prefix: 'Scheduler',
  date: true
});

importer = require("./importer");

konnectorHash = require('./konnector_hash');

Konnector = require('../models/konnector');

hour = 60 * 60 * 1000;

day = 24 * hour;

week = 7 * day;

month = 30 * day;

format = "DD/MM/YYYY [at] HH:mm:ss";

periods = {
  hour: hour,
  day: day,
  week: week,
  month: month
};

KonnectorPoller = (function() {
  function KonnectorPoller() {
    this.timeout = null;
    this.timeouts = {};
    this.nextUpdates = {};
  }

  KonnectorPoller.prototype.initializeKonnectorUpdates = function(konnector) {
    var nextUpdate;
    nextUpdate = this.findNextUpdate(konnector);
    return this.nextUpdates[konnector.slug] = [nextUpdate, konnector];
  };

  KonnectorPoller.prototype.findNextUpdate = function(konnector) {
    var importInterval, importTime, lastAutoImport, nextUpdate, now, slug, time;
    now = moment();
    importInterval = periods[konnector.importInterval];
    lastAutoImport = moment(konnector.lastAutoImport);
    if ((now.valueOf() - lastAutoImport.valueOf()) > importInterval) {
      log.debug(konnector.slug + " missed an importation cycle");
      importer(konnector);
      importTime = now;
      slug = konnector.slug;
      time = importTime.format(format);
      log.debug(slug + " | Next update: " + time);
      return importTime;
    } else {
      if (lastAutoImport.valueOf() > now.valueOf()) {
        nextUpdate = lastAutoImport;
      } else {
        nextUpdate = lastAutoImport.add(importInterval, 'ms');
      }
      slug = konnector.slug;
      time = nextUpdate.format(format);
      log.debug(slug + " | Next update: " + time);
      return nextUpdate;
    }
  };

  KonnectorPoller.prototype.manageNextChecks = function() {
    this.prepareNextCheck();
    if (this.timeout != null) {
      clearTimeout(this.timeout);
    }
    return this.timeout = setTimeout(this.start.bind(this), day);
  };

  KonnectorPoller.prototype.prepareNextCheck = function() {
    var konnector, nextUpdate, ref, results, slug, val;
    ref = this.nextUpdates;
    results = [];
    for (slug in ref) {
      val = ref[slug];
      nextUpdate = val[0], konnector = val[1];
      results.push(this.createTimeout(konnector, nextUpdate));
    }
    return results;
  };

  KonnectorPoller.prototype.createTimeout = function(konnector, nextUpdate) {
    var interval, now;
    now = moment();
    interval = nextUpdate.diff(now.clone(), 'ms');
    if (interval < day) {
      return this.startTimeout(konnector, interval);
    }
  };

  KonnectorPoller.prototype.startTimeout = function(konnector, interval) {
    var nextImport;
    nextImport = this.runImport.bind(this, konnector, interval);
    if (this.timeouts[konnector.slug] != null) {
      clearTimeout(this.timeouts[konnector.slug]);
    }
    return this.timeouts[konnector.slug] = setTimeout(nextImport, interval);
  };

  KonnectorPoller.prototype.runImport = function(konnector, interval) {
    var nextUpdate, now;
    log.info("Import scheduler starts import for " + konnector.slug);
    importer(konnector);
    now = moment();
    nextUpdate = now.add(periods[konnector.importInterval], 'ms');
    return this.schedule(konnector, nextUpdate);
  };

  KonnectorPoller.prototype.schedule = function(konnector, nextUpdate) {
    this.nextUpdates[konnector.slug] = [nextUpdate, konnector];
    log.info(konnector.slug + ": Next update " + (nextUpdate.format(format)));
    return this.createTimeout(konnector, nextUpdate);
  };

  KonnectorPoller.prototype.remove = function(konnector) {
    if (this.timeouts[konnector.slug] != null) {
      clearTimeout(this.timeouts[konnector.slug]);
      return delete this.timeouts[konnector.slug];
    }
  };

  KonnectorPoller.prototype.add = function(startDate, konnector, callback) {
    var data, fields;
    if (callback == null) {
      callback = null;
    }
    this.remove(konnector);
    if (konnector.importInterval !== 'none') {
      if (konnector.shallRaiseEncryptedFieldsError()) {
        konnector.importErrorMessage = 'encrypted fields';
      } else {
        konnector.injectEncryptedFields();
      }
      if (startDate != null) {
        data = {
          lastAutoImport: moment(startDate, 'DD-MM-YYYY').toDate(),
          importInterval: konnector.importInterval
        };
        fields = konnectorHash[konnector.slug];
        konnector.removeEncryptedFields(fields);
        return konnector.updateAttributes(data, (function(_this) {
          return function(err, body) {
            var nextUpdate;
            if (err) {
              log.error(err);
            }
            nextUpdate = _this.findNextUpdate(konnector);
            _this.nextUpdates[konnector.slug] = [nextUpdate, konnector];
            delete _this.timeouts[konnector.slug];
            if (callback != null) {
              return callback();
            }
          };
        })(this));
      } else {
        data = {
          lastAutoImport: new Date()
        };
        konnector.lastAutoImport = data.lastAutoImport;
        fields = konnectorHash[konnector.slug];
        konnector.removeEncryptedFields(fields);
        return konnector.updateAttributes(data, (function(_this) {
          return function(err, body) {
            if (err != null) {
              log.error(err);
            }
            _this.schedule(konnector, _this.findNextUpdate(konnector));
            if (callback != null) {
              return callback();
            }
          };
        })(this));
      }
    } else {
      if (callback != null) {
        return callback();
      }
    }
  };

  KonnectorPoller.prototype.start = function(reset, callback) {
    if (reset == null) {
      reset = false;
    }
    if (callback == null) {
      callback = null;
    }
    log.debug("Launching Konnector Poller...");
    if (reset) {
      this.nextUpdates = {};
    }
    if (Object.keys(this.nextUpdates).length === 0) {
      return Konnector.all((function(_this) {
        return function(err, konnectors) {
          return async.eachSeries(konnectors, function(konnector, next) {
            if ((konnector.importInterval != null) && konnector.importInterval !== 'none' && (konnector.lastAutoImport != null) && (konnectorHash[konnector.slug] != null)) {
              _this.initializeKonnectorUpdates(konnector);
            }
            return next();
          }, function(err) {
            if (callback != null) {
              callback();
            }
            return _this.manageNextChecks();
          });
        };
      })(this));
    } else {
      if (callback != null) {
        callback();
      }
      return this.manageNextChecks();
    }
  };

  return KonnectorPoller;

})();

module.exports = new KonnectorPoller;
